<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>DATA STRUCTURES & ALGORITHMS</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="DATA_STRUCTURES_&_ALGORITHMS.html">DATA STRUCTURES & ALGORITHMS</a></p>

<ol>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Asymptotic_Notation.html">Asymptotic Notation</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Complexity_Analysis_theory.html">Complexity Analysis theory</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Abstract_Data_Types(ADT).html">Abstract Data Types(ADT)</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions().html">Built-in Functions()</a></li>
<ol>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions()--Math.html">Math</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions()--Type_Conversion.html">Type Conversion</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions()--Iterable_and_iterators.html">Iterable and iterators</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions()--Composite_Data_Types.html">Composite Data Types</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions()--Classes,_Attributes,_Inheritance.html">Classes, Attributes, Inheritance</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions()--Input-Output.html">Input/Output</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions()--Variables,_References,_Scope.html">Variables, References, Scope</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions()--Miscellaneous.html">Miscellaneous</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Built-in_Functions()--Escape_Sequence.html">Escape Sequence</a></li>
</ol>
</ol>
<p><a href="WEB_DEVELOPMENT.html">WEB DEVELOPMENT</a></p>

<ol>
<li><a href="WEB_DEVELOPMENT--CSS.html">CSS</a></li>
<li><a href="WEB_DEVELOPMENT--CSS_LAYOUT.html">CSS LAYOUT</a></li>
</ol></div>
<div class="page"><h1><b><u>DATA STRUCTURES & ALGORITHMS</u></b></h1>Program = Data_Structure(pragramatic way of storing and representing data efficiently)  +  Algorithms ( playing with those data to provide correct result)<br /><br /><img src="images/2-1.png" alt="images/2-1.png" /><br /><br /><br />Two main Weapons of program for Solving All problems are :<br /> 1) Data Structure :  If the data is stored efficiently  or if best possible data structure has been selected according to the operation algorithm will be using, it will boost the RunTime(sorting,searching etc.) of Algorithm significantly because data structure has already made storing, retrieving and modifying data as fast as possible.<br /> <br />NOTE: Correct Data Structure will itself solve almost half of the problems which may be encountered while developing algorithm for solving problems. <br /> <br /> 2) Algorithms: Now after Correct data structure is selected, its time for an alogrithm to laverage those best structured data , take the operation to the next level. Now choosing the correct algorithm will again boost <br />                             the runtime of the program.<br /> <br /> Example: Consider a Scenerio where your program need to need to search for a integer key in a dynamic database of integers where more integers may be added overtime. What data structure will be the best ?<br /> Options can be :<br /> <br /> a) Array : <br /> &gt; If you are storing data in array, and using binary search algorithm, then you have to sort the data again and again everytime database changes and then start searching.<br /> &gt; WorstCase: O(n)<br /><br />b) Linked List:<br />&gt; it can aslo be used as it solves large data strorage and dynamic linking problem But Searching is still a problem.<br />&gt; In case of searching , Worstcase still be: O(n)<br /><br />c) Binary Search tree: <br />&gt; If you are using BST data structure for storing dynamic integers then your data is almost already sorted, and then algorithm only have to perform searching which will be much faster .<br />&gt; WorstCase: logn<br /><br />                    <br />So in this way, Deciding on Data St<span style="background-color:#000000;">ructure is really ve</span>ry efficient when you are not only concern about getting work done but also about speed and efficiency of your programs.<br /><br />So HOW TO DECIDE BEST DATA STRUCTURE FOR  A PARTICULAR PROBLEM ?<br />&gt;&gt;&gt; In Real World Scenerio, Data-Strutures mentioned in the book will not satisfy Most of your needs, you should be able to tweak it according to your requirements.<br />1. Complexity: Get Clear with What should be the Runtime Space Complexity and Time Complexity of the Program during Execution.<br />2. Are you dealing with Static data (which will never grow or grow very slowly) or Dynamic data (which grows faster and needs frequent modification and searching).<br />3.  Based on the above criteria, choosing or creating your own data-structure is need.<br />---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br />First, take a look at what you will be doing with the data items and ask yourself some questions:<br />---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br />do you need random access?<br />do you perform a lot of insertions? how about deletions?<br />do you allow duplicates?<br />are you searching for elements frequently?<br />does your data need to be ordered?<br />would you need to traverse the elements?<br />how big is your data?<br /><br /><img src="images/2-2.png" alt="images/2-2.png" /><br /><br /><h2>1. Array :</h2><br />   ☐ Advantages:<br /><br />   ◇ It is useful when you know the size you need and the size is small.<br />   ◇ If you need fast insertion and unordered elements but rare traversing then array becomes useful.<br />   ◇ If you need fast search in an array, use binary search.<br />   ◇ It is good for random access<br />      <br />   ☑  Disadvantages:<br />      ☐ The main demerit of array is the size must me allocated before hand which is a huge waste of memory.<br />      ☐ If a lot of deletions are needed then array is probably not the best data structure.<br />      ☐ Though a system has large free space but those free space might not be contigious so in this case again array will fail to work.<br /> <br /><br /><h2>2. Linked List :</h2><br />   1)  Advantages :<br />      1-  If you are not sure about the size of elements before hand, Linked list is better choice as it takes constant time O(1) for inserting at the end or begining of the list.<br />      2- Insertion can be comparatively faster than array since items are shifted only references are updated.<br />     <br />   2) Disadvantages:<br />      1- Deletion is still O(N)<br />      2- Binary Search is not possible because we cannot access element at the middle of the list.<br />      3- Random access is not possible as every other item is accessed starting from the first node.<br /> <br /><h2>3. Binary Tree:</h2><br />   1) Advantages:<br />      1- Ordered binary Tree provides faster O(logn) Searching, Insertion and deletion than arrays and linked list which is awesome.<br />      2- However if the tree is unblanced, insertion will become worse than array and linked list.<br />      3- If recursion is used, traversing binary tree in order is also possible.<br />      4- If you are sure that data inserted will be in random order, a regular binary tree might be a sufficient solution.<br />    <br /><h2>4. Hash Table:</h2><br />    1) Advantages: <br />      1- Searching and insertion,are super fast O(1) time.<br />      2- Even deletion can be achieved in O(1) time if deleted element is replace with a special flag in such a way that searching and insertion algorithm treats the flag as empty cell.<br />     <br />     2) Disadvantages:<br />        1-  Traversing the elements are not possible at all.<br />        2- hash tables are even faster than trees but degrade catastrophically when the load factor gets too big as they are based on arrays whose accurate size/number of elements need to known before hand.<br />&gt;&gt;&gt; If you cannot predict the size of the elements beforehand , it is better to use separate chaining method over open addressing method to implement hash table.<br /><br /><br />ABASTRACT DATA TYPES In Data Structures are logical data types which advertise their behaviour which is always same in any programming language but they might be implmented in various ways which<br />is not considered important so it is mostly kept hidden.<br /><img src="images/2-3.png" alt="images/2-3.png" /><br /><br />&gt; Priority queue is a sorted queue by priority (from greatest to lowest key). Insertion in a priority queue runs in O(N) time, while removal is still in constant time<br /><br /><img src="images/2-4.png" alt="images/2-4.png" /><br /><br />&gt; Insertion Sort is the best if data is too small (in 3 digits) because it is too implement.<br />&gt; Shell sort would be better if data is in (4 digits or more)<br />&gt; It you have a large data set, Complex sorting algorithms like mergesort and quicksort is needed<br />&gt; Mergesort requires an extra array than quicksort to perform sorting which will not be good if the system has limited memory.<br />&gt; But Quicksort  can perform sorting as fast mergesort and even faster than merge sort in worse case without needing extra memory space.<br />   However if the items are not random, Quicksort sorting degrades to O(n<sup>2</sup>).<br />                    <br /></div></div>
</body></html>