<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Complexity Analysis theory</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css" />
</head>
<body><div class="main"><div class="tree">
<p><strong>Index</strong></p>
<p><a href="DATA_STRUCTURES_&_ALGORITHMS.html">DATA STRUCTURES & ALGORITHMS</a></p>

<ol>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Asymptotic_Notation.html">Asymptotic Notation</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Complexity_Analysis_theory.html">Complexity Analysis theory</a></li>
<li><a href="DATA_STRUCTURES_&_ALGORITHMS--Abstract_Data_Types.html">Abstract Data Types</a></li>
</ol>
<p><a href="WEB_DEVELOPMENT.html">WEB DEVELOPMENT</a></p>

<ol>
<li><a href="WEB_DEVELOPMENT--CSS.html">CSS</a></li>
<li><a href="WEB_DEVELOPMENT--CSS_LAYOUT.html">CSS LAYOUT</a></li>
</ol></div>
<div class="page"><h1><b><u>Complexity Analysis theory</u></b></h1><h3>What is Complexity Analysis ?</h3><br /><br />•  Suppose you have given two or more alogithm to solve a problem, how do you select best one .<br />•  So We mainly have 3 criteria to focus on: a) Maintaibility and Scalability b) Time Complexity c) Space Complexity<br />• &gt;Efficiency of an algorithm should be machine indpendent i.e if an algorithm performs really well on machine A but not on machine B then it is not good.<br />•  For determining the efficiency of an algorithm :<br />      •    you need to find out NO._OF_BASIC_OPERATIONS an algorithm performs and how those no. of basic operations get affected when INPUT_SIZE increases<br />      •    Basic Operations: Those operations which need always same or constant amount of time to execute like comparison, arithmatic operations, memory access, assignments, input, output etc.<br />      •    Non Basic Operations: Sorting, Searching inside an array are non basic operations.<br />• &gt;Since often TIME_COMPLEXITY is used over Space_Complexity to find the efficiency of an algorithm, let's focus on time_complexity:<br /> <br /><h3> How to calculate Running time ( T(n) )of an algorithm ?</h3><br /><br />1. Best case : is useless because we don't get such good inputs in real world scenerio<br />2. Average case : is useful but often difficult to determine<br />3. Worst case :  is the Most important for almost all kinds of large applications.<br /><br /><em>&gt;&gt;&gt; Here we are not concerned about how much time an operation takes to execute on a computer BUT rather HOW MANY TIMES THAT OPERATION EXECUTES IN PROGRAM.</em><br /><br /><img src="images/1-1.png" alt="images/1-1.png" /><br /><img src="images/1-2.png" alt="images/1-2.png" /><img src="images/1-3.png" alt="images/1-3.png" /><br />CONCLUSION 1: The time complexity of Loops in which control variable is incremented or decremented by a constant number is O(n).<br /><br /><img src="images/1-4.png" alt="images/1-4.png" /><br /> CONCLUSION 2: In a Loop if the control variable is divided or multiplied then time_complexity is O(logn)<br /> <br /> <img src="images/1-5.png" alt="images/1-5.png" /> <br /> CONCLUSION 3: In case of nested-loop, time complexity of inner-most loop will be faster growing so it's time complexity will always be dominant to innermost-loop.<br /> <br /> <img src="images/1-6.png" alt="images/1-6.png" /><br /> CONCLUSION 4: The figure is self-explanatory.<br /> <br /> <img src="images/1-7.png" alt="images/1-7.png" /><br /> CONCLUSION 5: The figure is self-explanatory.<br /> <br /> <img src="images/1-8.png" alt="images/1-8.png" /><br /> CONCLUSION 6: When iteration of inner-loop depends on index of outer-loop, then no. of total iteration of inner-most loop is added.<br /> <br /> <img src="images/1-9.png" alt="images/1-9.png" /><br /> CONCLUSION 7: Same as Conclusion 6<br /> <br /> <img src="images/1-10.png" alt="images/1-10.png" /><br /> CONCLUSION 8: It is a Selection Sort Algorithm<br /> <br /> <img src="images/1-11.png" alt="images/1-11.png" /><br /> CONCLUSION  9: It is a Bubble Sort Algorithm<br /> <br /> <img src="images/1-12.png" alt="images/1-12.png" /><br /> CONCLUSION 10: In case of if else statements,  the condition whose order is larger is considered, So since order of if block is n<sup>2</sup> and else block is n, <br />                            finally order of if block is considered.<br /><br /><img src="images/1-13.png" alt="images/1-13.png" /><br />CONCLUSION 11:  If an algorithm executes constant no. of times no matter what is the size of input(independent of input size), the order of such algorithm is always O(1).<br />                                  Examples, SwapFirstLast(), printlastElement(), returnSizeoFStact(), this above figure example.<br />                                  <br />                                  <br />☐ O(1) → Constant → inserting an element at first location of an array<br />☐ O(logn) → Logarithmic → solves problems by dividing large problem into smaller problems → Binary Search<br />☐ O(n) → Linear → algorithms that print all elements of an array or insert an element at the end of a linkedlist<br />☐ O(nlogn) → Linear logarithmic → Merge Sort algorithm<br />☐ O(n<sup>2</sup>) → Quadratic → algorithms that involves nested iterations over the input → Bubble Sort &amp; Selection Sort<br />☐ O(n<sup>3</sup>) → Cubic → matrix multiplications<br />☐ O(n<sup>K</sup>) → Polynomial<br />☐ O(a<sup>n</sup>) → Exponential → tower of hanoi problem<br /></div></div>
</body></html>